// Generated by CoffeeScript 1.4.0
(function() {
  var CFDVisualizer, Time, lumenize, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  utils = lumenize.utils, Time = lumenize.Time;

  CFDVisualizer = (function(_super) {

    __extends(CFDVisualizer, _super);

    function CFDVisualizer() {
      this.onNewDataAvailable = __bind(this.onNewDataAvailable, this);
      return CFDVisualizer.__super__.constructor.apply(this, arguments);
    }

    /*
    */


    CFDVisualizer.prototype.initialize = function() {
      var allowedValues, cs;
      if (this.config.trace) {
        console.log('in CFDVisualizer.initialize');
      }
      CFDVisualizer.__super__.initialize.call(this);
      if (this.config.granularity != null) {
        this.config.lumenizeCalculatorConfig.granularity = this.config.granularity;
      } else {
        this.config.lumenizeCalculatorConfig.granularity = lumenize.Time.DAY;
      }
      this.config.lumenizeCalculatorConfig.workDayStartOn = this.config.workDayStartOn;
      this.config.lumenizeCalculatorConfig.workDayEndBefore = this.config.workDayEndBefore;
      this.config.lumenizeCalculatorConfig.holidays = this.config.holidays;
      this.config.lumenizeCalculatorConfig.workDays = this.config.workDays;
      this.config.lumenizeCalculatorConfig.startOn = new Time(this.config.scopeData.StartDate, Time.MILLISECOND, this.config.lumenizeCalculatorConfig.tz).getISOStringInTZ('GMT');
      this.config.lumenizeCalculatorConfig.endBefore = new Time(this.config.scopeData.EndDate, Time.MILLISECOND, this.config.lumenizeCalculatorConfig.tz).addInPlace(1, this.config.lumenizeCalculatorConfig.granularity).getISOStringInTZ('GMT');
      allowedValues = (function() {
        var _i, _len, _ref, _results;
        _ref = this.config.chartSeries;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cs = _ref[_i];
          _results.push(cs.name);
        }
        return _results;
      }).call(this);
      this.config.lumenizeCalculatorConfig.metrics = [
        {
          f: 'groupByCount',
          groupByField: this.config.kanbanStateField,
          allowedValues: allowedValues
        }
      ];
      return this.LumenizeCalculatorClass = lumenize.TimeSeriesCalculator;
    };

    CFDVisualizer.prototype.onNewDataAvailable = function() {
      var fields, queryConfig, scopeValue;
      if (this.config.trace) {
        console.log('in CFDVisualizer.onNewDataAvailable');
      }
      queryConfig = {
        'X-RallyIntegrationName': 'Burn Chart (prototype)',
        'X-RallyIntegrationVendor': 'Rally Red Pill',
        'X-RallyIntegrationVersion': '0.2.0',
        workspaceOID: this.projectAndWorkspaceScope.workspaceOID
      };
      if (this.upToDateISOString == null) {
        this.upToDateISOString = '2011-12-01T00:00:00.000Z';
      }
      this.analyticsQuery = new GuidedAnalyticsQuery(queryConfig, this.upToDateISOString);
      if (this.config.scopeValue === 'scope') {
        if (this.projectAndWorkspaceScope.projectScopingUp) {
          if (this.config.debug) {
            console.log('Project scoping up. OIDs in scope: ', this.projectAndWorkspaceScope.projectOIDsInScope);
          }
          this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOIDsInScope);
        } else if (this.projectAndWorkspaceScope.projectScopingDown) {
          if (this.config.debug) {
            console.log('Project scoping down. Setting _ProjectHierarchy to: ', this.projectAndWorkspaceScope.projectOID);
          }
          this.analyticsQuery.scope('_ProjectHierarchy', this.projectAndWorkspaceScope.projectOID);
        } else {
          if (this.config.debug) {
            console.log('Project with no up or down scoping. Setting Project to: ', this.projectAndWorkspaceScope.projectOID);
          }
          this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOID);
        }
      } else if (this.config.scopeData.ObjectID != null) {
        scopeValue = this.config.scopeData.ObjectID;
        this.analyticsQuery.scope(this.config.scopeField, scopeValue);
      } else {
        scopeValue = this.config.scopeValue;
        this.analyticsQuery.scope(this.config.scopeField, scopeValue);
      }
      fields = ["ObjectID", "_ValidFrom", "_ValidTo", "PlanEstimate"];
      fields.push(this.config.kanbanStateField);
      this.analyticsQuery.type(['HierarchicalRequirement', 'Defect', 'TestCase', 'DefectSuite']).leafOnly().fields(fields).hydrate([this.config.kanbanStateField]);
      if (this.config.asOf != null) {
        this.analyticsQuery.additionalCriteria({
          _ValidFrom: {
            $lt: this.getAsOfISOString()
          }
        });
      }
      if (this.config.debug) {
        this.analyticsQuery.debug();
        console.log('Requesting data...');
      }
      this.fetchPending = true;
      return this.analyticsQuery.getPage(this.onSnapshotsReceieved);
    };

    CFDVisualizer.prototype.getHashForCache = function() {
      var hashObject, hashString, out, salt, userConfig;
      if (this.config.trace) {
        console.log('in CFDVisualizer.getHashForCache');
      }
      hashObject = {};
      userConfig = utils.clone(this.userConfig);
      delete userConfig.debug;
      delete userConfig.trace;
      hashObject.userConfig = userConfig;
      hashObject.projectAndWorkspaceScope = this.projectAndWorkspaceScope;
      hashObject.workspaceConfiguration = this.workspaceConfiguration;
      salt = 'CFD v0.2.11';
      salt = Math.random().toString();
      hashString = JSON.stringify(hashObject);
      out = md5(hashString + salt);
      return out;
    };

    CFDVisualizer.prototype.updateVisualizationData = function() {
      var calculatorResults, categories, lowestValueInLastState, row, s, series, seriesData, _i, _len;
      if (this.config.trace) {
        console.log('in CFDVisualizer.updateVisualizationData');
      }
      calculatorResults = this.lumenizeCalculator.getResults();
      if (calculatorResults.length === 0) {
        if (this.config.debug) {
          console.log('No calculatorResults.');
        }
        if (this.fetchPending) {
          if (this.config.debug) {
            console.log('fetchPending is true so returning with visualizationData = null.');
          }
          this.visualizationData = null;
          return;
        } else {
          series = [];
          if (this.config.debug) {
            console.log('fetchPending is false so filling in with blanks');
          }
        }
      } else {
        this.virgin = false;
      }
      seriesData = calculatorResults.seriesData;
      series = lumenize.arrayOfMaps_To_HighChartsSeries(seriesData, this.config.chartSeries);
      for (_i = 0, _len = series.length; _i < _len; _i++) {
        s = series[_i];
        if (s.displayName != null) {
          s.name = s.displayName;
        }
      }
      categories = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = seriesData.length; _j < _len1; _j++) {
          row = seriesData[_j];
          _results.push(row.label);
        }
        return _results;
      })();
      lowestValueInLastState = lumenize.functions.min(series[series.length - 1].data);
      return this.visualizationData = {
        series: series,
        categories: categories,
        lowestValueInLastState: lowestValueInLastState
      };
    };

    CFDVisualizer.prototype.updateVisualization = function() {
      var chart, index, s, series, _i, _len, _ref;
      this.updateVisualizationData();
      this.visualizations.lowestValueInLastState = this.visualizationData.lowestValueInLastState;
      chart = this.visualizations.chart;
      chart.yAxis[0].setExtremes(this.visualizationData.lowestValueInLastState);
      series = chart.series;
      _ref = this.visualizationData.series;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        s = _ref[index];
        series[index].setData(s.data, false);
      }
      chart.xAxis[0].setCategories(this.visualizationData.categories, false);
      return chart.redraw();
    };

    return CFDVisualizer;

  })(VisualizerBase);

  this.CFDVisualizer = CFDVisualizer;

}).call(this);
